<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<!--
Check output with <http://tools.ietf.org/tools/idnits/>
-->

<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.35) -->

<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>

<!-- control the table of contents (ToC) -->
<!-- generate a ToC -->
<?rfc toc="no"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="3"?>

<!-- control references -->
<!-- use anchors instead of numbers for refs, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="no" ?>

<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<!-- do not start each main section on a new page -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>

<!-- encourage use of "xml2rfc" tool -->
<?rfc rfcprocack="yes" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="info" docName="draft-sctl-service-registration-02" ipr="trust200902">

  <front>
    <title abbrev='Service Registration Protocol'>Service Registration Protocol for DNS-Based Service Discovery</title>
    <author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
        </postal>
        <phone>+1 408 974 3207</phone>
        <email>cheshire@apple.com</email>
      </address>
    </author>

    <author initials="T" surname="Lemon" fullname="Ted Lemon">
      <organization>Nibbhaya Consulting</organization>
      <address>
        <postal>
          <street>P.O. Box 958</street>
          <city>Brattleboro</city>
          <region>Vermont</region>
          <country>United States of America</country>
          <code>05302</code>
        </postal>
        <email>mellon@fugue.com</email>
      </address>
    </author>

    <date year='2018' month='July' day='11'/>
    <area>Internet</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>Multicast DNS</keyword>
    <keyword>DNS-Based Service Discovery</keyword>
    <keyword>DNS Update</keyword>
    <keyword>SIG(0)</keyword>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>The DNS-SD Service Registration Protocol uses the standard DNS Update mechanism to
      enable DNS-Based Service Discovery using only unicast packets.  This eliminates the
      dependency on Multicast DNS as the foundation layer, which greatly improves scalability
      and improves performance on networks where multicast service is not an optimal choice,
      particularly 802.11 (WiFi) and 802.15 (IoT) networks.   DNS-SD Service registration uses
      public keys and SIG(0) to allow services to defend their registrations against attack.
      </t>
    </abstract>
  </front>

  <middle>

    <section title="Introduction">
      <t><xref target="RFC6763">DNS-Based Service Discovery</xref>
      is a component of Zero Configuration Networking
      <xref target="RFC6760"/> <xref target="ZC"/> <xref target="I-D.cheshire-dnssd-roadmap"/>.</t>

      <t>This document describes an enhancement to <xref target="RFC6763">DNS-Based Service
      Discovery</xref> that allows services to register using the DNS protocol rather than using
      mDNS.  This document is intended for three audiences: implementors of software that
      provides services that should be advertised using DNS-SD, implementors of DNS servers that
      will be used in contexts where DNS-SD registration is needed, and administrators of
      networks where DNS-SD service is required.  The document is intended to provide sufficient
      information to allow interoperable implementation of the registration protocol.</t>


      <t>DNS-Based Service Discovery (DNS-SD) allows services to advertise the fact that they
      provide service, and to provide the information required to access that service.  Clients
      can then discover the set of services of a particular type that are available.  They can
      then select a service from among those that are available and obtain the information
      required to use it.</t>

      <t>The DNS-SD Service Registration protocol, described in this document, provides a
      reasonably secure mechanism for publishing this information: what services are offered,
      and how to use them.  Once published, these services can be readily discovered by clients
      using standard DNS lookups.</t>

      <t>In the <xref target="RFC6763">DNS-Based Service Discovery specification</xref> Section
      10 “Populating the DNS with Information” briefly discusses ways that services can publish
      their information in the DNS namespace.  In the case of <xref target="RFC6762">Multicast
      DNS</xref>, it allows clients to directly query services on the local link for names in the
      ".local" namespace.</t>

      <t>RFC6763 also allows clients to discover services using <xref target="RFC1035">the DNS
      protocol</xref>; this is done either by having a system administrator manually configure
      service information in the DNS, or by using a <xref target="I-D.ietf-dnssd-hybrid">Discovery
      Proxy</xref>, which performs mDNS queries on behalf clients that issue queries using DNS.
      This eliminates the "link local" limitation of mDNS, but provides no additional security,
      and still relies on multicast.</t>

      <t>Manually populating DNS server databases is costly and potentially error-prone, and
      requires a knowledgable network administrator.  Consequently, although all DNS-SD client
      implementations of which we are aware support DNS-SD using DNS queries, it is much less
      frequently deployed than mDNS.  This document describes a solution: a way to deploy DNS-SD
      in DNS that can be as automatic as mDNS, but with better performance, scalability and
      security.</t>
    <?rfc needLines="20" ?>
    </section>

    <section title="Service Registration Protocol">

      <t>Services using the DNS-SD Service Registration Protocol use DNS Update <xref
      target="RFC2136"/> <xref target="RFC3007"/> to publish service information in the DNS.  We
      will discuss several parts to this process: how to know what to publish, how to know where
      to publish it (under what name), how to publish it, how to secure its publication, and how
      to maintain the information once published.</t>

      <section title="What to publish">
	<t>We refer to the message that services using the DNSSD Registration Protocol send
	as a Registration.   Four types of updates can appear in a Registration: Service Name updates,
	Service Instance Name updates, Forward Mapping updates and Inverse Mapping updates.
	<list style="symbols">
	  <t>Service Name (<xref target="RFC6763"/> section 4.1.1) updates contain a PTR RRset
	  update with one or more (typically one) PTR RRs, each of which points to a Service
	  Instance Name that is included in the Registration.  Service Name updates do not
	  update any other type of RR.</t>
	  <t>Service Instance Name (<xref target="RFC6763"/> section 4.1.2) updates contain
	  exactly one SRV RR, and one or more TXT RRs.  They do not update any other RR type.
	  Every Service Instance Name update in a Registration MUST be referenced by at least
	  one PTR RR update in that Registration.</t>
	  <t>Forward Mapping updates contain an update to either an A or an AAAA RR, and an update to a
	  KEY RR.</t>
	  <t>Inverse Mapping updates contain an update to a PTR RR.  The PTR RR in an Inverse
	  Mapping update MUST reference the name of a Forward Mapping update.  Inverse Mappings for IP
	  addresses are typically stored on subdomain names of the "IN-ADDR.ARPA" domain (<xref
	  target="RFC1034"/> section 3.3) for IPv4 addresses or the "IP6.ARPA" domain (<xref
	  target="RFC3152"/>).  However, Updates are required to be to a single zone, and
	  indeed a site may choose to use some mapping other than the default.  Therefore,
	  Inverse Mapping updates use ".local" instead of ".arpa".  So for example the name of a
	  reverse entry for an IPv4 address will look like: "1.2.0.192.in-addr.local".  The name
	  of a reverse entry for an IPv6 address will look like:
	  "0.f.e.d.c.b.a.9.8.7.6.5.4.3.2.1.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.local".</t>
	</list></t>
	<t>RFC 6763 describes the details of what each of these types of updates contains and is
	the definitive source for information about what to publish; the reason for mentioning
	it here is to provide the reader with enough information about what will be published
	that the service registration process can be understood at a high level without first
	learning the full details of DNS-SD.  Also, the "Service Instance Name" is an important
	aspect of first-come, first-serve naming, which we describe later on in this
	document.</t>
      </section>

      <section title="Where to publish it">
	<t>Multicast DNS uses a single namespace, ".local", which is valid on the local link.
	This convenience is not available for DNS-SD using the DNS protocol: the portion of the
	DNS namespace in which services on the local network are to be published must be discovered
	by the service before it can register itself.</t>

	<t>Names published using DNS-SD service registration will be published under some name
	other than .local.  However, the process of discovering what that name is is
	complicated, and for any given network it should always be the case that there will be
	just one namespace in which registered names will be published.  Rather than requiring
	the service to discover this name before issuing a registration, the service SHOULD
	simply use the name ".local."  The DNS server that receives the registration request
	will rewrite all instances of the terminal label ".local" to use the local registration
	domain name.  The response to the DNS Update being used to register the service will
	contain the rewritten names, instead of ".local".  Subsequent updates should still use
	the ".local" domain and not the registration domain, since the registration domain may
	change over time or when the service is physically moved to a new network.</t>

	<t>This should not be taken to mean that it is not permissible for some Registrations
	to be published under one domain, and others to be published under another.   Rather,
	it is only REQUIRED that any given Registration be consistently published under
	the same domain.  In other words, whatever process is used to decide which domain to
	substitute for .local, that process must always produce the same outcome for any given
	service.</t>

	<t>So for example, a site might set up a whitelist so that known services are
	registered in one domain, while unknown services are registered in another.   It is
	of course permissible that when a change is made to such a whitelist, the services
	affected by this change might then be registered in different domains: the requirement
	for consistency is just that absent such a configuration change, the registered domain
	will always be consistent per service.</t>
      </section>

      <section title="How to publish it">
	<t>It is possible to issue a DNS Update that does several things at once; this means
	that it's possible to do all the work of adding a PTR resource record to the PTR RRset
	on the Service Name if it already exists, or creating one if it doesn't, and creating or
	updating the Service Instance Name in a single transaction.</t>

	<t>A Registration is therefore implemented as a single DNS Update message that contains
	one or more Service Name updates, one or more Service Instance Name updates, exactly one
	Forward Mapping update, and, optionally, one Inverse Mapping update.  The Inverse Mapping update
	is not required because it is not used for service discovery, but may be useful for
	debugging, or for associating an IP address with the public key in the KEY record
	included in the Forward Mapping update.</t>

	<t>Updates done according to this specification are somewhat different than regular DNS
	Updates as defined in RFC2136.  RFC2136 assumes that updating is a fairly heavyweight
	process, so you might first attempt to add a name if it doesn't exist, and then in a
	second message update the name if it does exist but matches certain preconditions.
	Because the registration protocol uses a single transaction, some of this adaptability
	is lost.</t>

	<t>In order to allow updates to happen in a single transaction, Registrations do not
	include update constraints.   The constraints specified in <xref target="server_behavior"/>
	are implicit in the processing of Registrations, and so there is no need for the
	service sending the Registration to put in any explicit constraints.</t>

	<t>There are two ways of sending Registrations.  The first is to use UDP Anycast.  The
	update is sent to port 53 on ANYCAST_IPv4 and/or ANYCAST_IPv6.  The second way is to
	discover the default registration domain, discover the DNS Update server to use for that
	zone, and then make a TCP connection to that server and send the update using DNS over
	TCP.</t>

	<t>Hosts connected to LLNs should use ANYCAST_IPv6.  Hosts that are not connected to
	LLNs should attempt both anycast addresses, if both protocols are available, and also
	attempt to do the update using TCP.  LLNs are assumed to provide anycast Registration
	Protocol service using UDP over IPv6; other networks may or may not support Anycast
	registration, but are assumed, if they support registration at all, to at least support
	updating over TCP.</t>

	<t>The reason for these different assumptions is that LLNs generally require special
	egress support, and Anycast packets captured at the LLN interface of the egress can be
	assumed to have originated locally.  Low-power devices that typically use LLNs may
	have very limited battery power, and so the additional DNS lookups required to discover
	a registration server and then communicate with it using TCP will dramatically increase
	the power required to advertise a service.</t>

	<t>Non-LLN networks have the potential to have more complicated topologies at the
	Internet layer, which makes Anycast routing more difficult.  Such networks may or may
	not have the infrastructure required to route Anycast to a server that can process it.
	However, they can be assumed to be able to provide registration domain discovery and
	routing.  By requiring the use of TCP, the possibility of off-network spoofing is
	eliminated.</t>

	<t>How hosts on non-LLN networks should order their update attempts is up to the
	implementation, and should be based on that implementation's anticipated use cases.
	It is out of scope for this document to speculate in detail about how this tradeoff
	will be made.   However, such hosts MUST attempt both TCP and Anycast UDP updates
	in some order, or may do both at the same time.</t>

	<t>Although the standard DNSSD discovery process is followed when discovering the
	server to which to send updates, the updates should still be to the ".local" zone,
	and not to the advertized default registration zone.   The default registration
	zone is merely used to locate the correct SRV record to use when sending the update.</t>

	<section anchor="reg_discover" title="Discovering the Registration domain and server">
	  <t>The discovery process for the default registration domain
	  (dr._dns_sd._udp.&lt;domain&gt;) is detailed in <xref target="RFC6763"/> section 11.
	  In order to discover where to send the update, the service should look for an SRV
	  record under _dns-update._udp.&lt;zone&gt;, where "zone" is the default registration
	  zone.</t>
	</section>

	<section title="Testing using RFC2136-capable non-conforming servers">
	  <t>It may be useful to set up a DNS server for testing that does not implement the
	  Registration protocol.  This can be done by configuring the server to listen on
	  ANYCAST_IPv4 and/or ANYCAST_IPv6, or advertising it as described in <xref
	  target="reg_discover"/>.  It must be configured to be authoritative for ".local", and
	  to accept updates from hosts on local networks for names under ".local" without
	  authentication.</t>

	  <t>A server configured in this way will be able to successfully accept and process
	  Registrations from services that send Registrations.  However, no constraints will be
	  applied, and this means that the test server will accept internally inconsistent
	  Registrations, and will not stop two Registrations, sent by different services, that
	  claim the same name(s), from overwriting each other.</t>
	</section>

	<section title="How to allow services to update non-conforming RFC2136 servers">
	  <t>Ordinarily Registrations will fail when sent to any non-Registration Protocol
	  server because the zone being updated is ".local", and no DNS server should normally
	  be configured to be authoritative for "local."  Therefore, a service that sends a
	  Registration can tell that the receiving server does not support the Registration
	  Protocol but does support RFC2136 because the RCODE will either be NOTZONE, NOTAUTH or
	  REFUSED, or because there is no response to the update request (when using the anycast
	  address)</t>

	  <t>In this case a service MAY attempt to register itself using regular RFC2136 DNS
	  updates. To do so, it must discover default registration zone and the DNS server
	  designated to receive updates for that zone, as described earlier in <xref
	  target="reg_discover"/>.  It can then make the update using the port and host pointed
	  to by the SRV record, and should use appropriate constraints to avoid overwriting
	  competing records.  Such updates are out of scope for the DNSSD Registration Protocol,
	  and a service that implements the DNSSD Registration Protocol MUST first attempt to
	  use the Registration Protocol to register itself, and should only attempt to use
	  RFC2136 backwards compatibility if that fails.</t>
	</section>
      </section>

      <section title="How to secure it">
	<t>Traditional DNS update is secured using the TSIG protocol, which uses a secret key
	shared between the client (which issues the update) and the server (which authenticates
	it).  This model does not work for automatic service registration.</t>

	<t>The goal of securing the DNS-SD Registration Protocol is to provide the best possible
	security given the constraint that service registration has to be automatic.  It is
	possible to layer more operational security on top of what we describe here, but what we
	describe here improves upon the security of mDNS.  The goal is not to provide the level
	of security of a network managed by a skilled operator.</t>

	<section anchor="fcfs" title="First-Come First-Served Naming">
	  <t>First-Come First-Serve naming provides a limited degree of security: a service that
	  registers its service using DNS-SD Registration protocol is given ownership of a name
	  for an extended period of time based on the key used to authenticate the DNS Update.
	  As long as the registration service remembers the Service Instance Name and the key used
	  to register that Service Instance Name, no other service can add or update the information
	  associated with that Service Instance Name.</t>
	  <section title="Service Behavior">
	    <t>The service generates a public/private key pair.   This key pair MUST be stored
	    in stable storage; if there is no writable stable storage on the client, the client
	    MUST be pre-configured with a public/private key pair that can be used.</t>

	    <t>When sending DNS updates, the service includes a KEY record containing the public
	    portion of the key in each Forward Mapping update.  The update is signed using SIG(0), using
	    the private key that corresponds to the public key in the KEY record.</t>

	    <t>The lifetime of the <xref target="RFC6763">DNS-SD PTR, SRV, A, AAAA and TXT
	    records</xref> is typically set to two hours.  This means that if a device is
	    disconnected from the network, it does not appear in the user interfaces of devices
	    looking for services of that type for too long.</t>

	    <t>However, the lifetime of its KEY record should be set to a much longer time,
	    typically 14 days.  The result of this is that even though a device may be
	    temporarily unplugged, disappearing from the network for a few days, it makes a
	    claim on its name that lasts much longer.</t>

	    <t>This way, even if a device is unplugged from the network for a few days,
	    and its services are not available for that time, no other rogue device
	    can come along and immediately claim its name the moment it disappears
	    from the network, and yet the name is eventually cleaned up and made available for
	    re-use.</t>
	  </section>
	</section>

	<section anchor="server_behavior" title="Registration Server Behavior">
	  <t>The Registration server checks each update in the Registration to see that it is
	  either a Service Name update, a Service Instance Name update, a Forward Mapping
	  update, or a Reverse Mapping update.</t>

	  <t>An update is a Service Name update if
	  <list style="symbols">
	    <t>it contains exactly one RRset update,</t>
	    <t>which is for a PTR RR,</t>
	    <t>which points to a Service Instance Name</t>
	    <t>for which an update is present in the Registration.</t>
	  </list></t>

	  <t>An update is a Service Instance Name update if
	  <list style="symbols">
	    <t>it contains exactly one SRV RRset delete,</t>
	    <t>exactly one SRV RRset update,</t>
	    <t>exactly one TXT RRset delete,</t>
	    <t>zero or more TXT RRset updates,</t>
	    <t>no other RRset updates,</t>
	    <t>no other RRset deletes,</t>
	    <t>the SRV record points to a Forward Mapping for which there is an update in
	    the Registration.</t>
	  </list></t>

	  <t>An update is a Forward Mapping update if
	  <list style="symbols">
	    <t>it contains either an A or AAAA RRset delete (according to the address family
	    of the source IP address of the Registration message),</t>
	    <t>an A or AAAA RR update with the source IP address of the Registration
	    message,</t>
	    <t>a KEY RR update that adds a KEY RR that contains the public key corresponding to the
	    private key that was used to sign the message,</t>
	    <t>there is a Service Instance Name update in the Registration that updates an
	    SRV RR so that it points to the name being updated by this update.</t>
	  </list></t>

	  <t>An update is a Reverse Mapping update if
	  <list style="symbols">
	    <t>it updates a name that is the reverse mapping name for the source IP address
	    (IPv4 or IPv6) of the Registration message,</t>
	    <t>it includes one PTR RRset delete,</t>
	    <t>it includes one RRset update for a PTR record, and</t>
	    <t>the Registration message includes a Forward Mapping update for the name to
	    which the PTR record points.</t>
	  </list></t>

	  <t>A Registration MUST include at least one Service Name update, at least one Service
	  Instance Name update, and exactly one Forward Mapping update.  An update message that
	  does not is not a Registration.  An update message that contains any other updates, or
	  any update constraints, is not a Registration.  Such messages should either be
	  processed as regular RFC2136 updates, including access control checks and constraint
	  checks, if supported, or else rejected with RCODE=REFUSED.</t>

	  <t>Note that if the definitions of each of these update types are followed carefully,
	  this means that many things that look very much like Registrations nevertheless are
	  not.  For example, a Registration that contains an update to a Service Name and an
	  update to a Service Instance Name, where the Service Name does not reference the
	  Service Instance Name, is not a valid Registration message, but may be a valid RFC2136
	  update.</t>

	  <t>Assuming that an update message has been validated with these conditions and is a
	  valid Registration, the server checks that the name in the Forward Mapping update
	  exists.  If so, then the server checks to see if the KEY record on the name is the
	  same as the KEY record in the update.  If it is not, then the DNS Update is rejected
	  with the YXDOMAIN RCODE.</t>

	  <t>Otherwise, the server validates the update using SIG(0) on the public key in the
	  KEY record of the Forward Mapping update.  If the validation fails, the update is
	  rejected with REFUSED.  Otherwise, the update is considered valid and authentic, and
	  is processed according to the method described in RFC2136.  The status that is
	  returned depends on the result of processing the update.</t>

	  <t>The server MAY add a Reverse Mapping that corresponds to the Forward Mapping.
	  This is not required because the Reverse Mapping serves no protocol function, but
	  it may be useful for debugging, e.g. in annotating network packet traces or logs.</t>

	  <t>The server MAY apply additional criteria when accepting updates.   In some networks,
	  it may be possible to do out-of-band registration of keys, and only accept updates
	  from pre-registered keys.  In this case, an update for a key that has not been registered
	  should be rejected with the REFUSED RCODE.</t>

	  <t>There are at least two benefits to doing this rather than simply using normal
	  SIG(0) DNS updates.  First, the same registration protocol can be used in both cases,
	  so both use cases can be addressed by the same service implementation.  Second, the
	  registration protocol includes maintenance functionality not present with normal DNS
	  updates.</t>
	  
	  <t>The server may also have a dictionary of names or name patterns that are not
	  permitted.  If such a list is used, updates for Service Instance Names that match
	  entries in the dictionary are rejected with YXDOMAIN.</t>
	</section>
      </section>

      <section title="Maintenance">
	<section title="Cleaning up stale data">
	  <t>Because the DNS-SD registration protocol is automatic, and not managed by humans,
	  some additional bookkeeping is required.  When an update is constructed by the client,
	  it MUST include include an EDNS(0) Update Lease option and an EDNS(0) Instance Lease
	  option.</t>

	  <t>These leases are promises, similar to <xref target="RFC2131">DHCP leases</xref>,
	  from the client that it will send a new update for the service registration before the
	  lease time expires.  The Update Lease time is chosen to represent the time after the
	  update during which the registered records other than the KEY record should be assumed
	  to be valid.  The Instance Lease time represents the time after the update during
	  which the KEY record should be assumed to be valid.</t>

	  <t>The reasoning behind the different lease times is discussed in the section on first-come,
	  first-served naming <xref target="fcfs"/>.   DNS-SD Registration Protocol servers may be configured
	  with limits for these values.   A default limit of two hours for the Update Lease and 30 days for the
	  Instance Lease are currently thought to be good choices.   Clients that are going to continue to use
	  names on which they hold leases should update well before the lease ends, in case the registration
	  service is unavailable or under heavy load.</t>

	  <t>Clients should assume that each lease ends N seconds after the update was first transmitted, where
	  N is the number included in the option.   Servers should assume that each lease ends N seconds after
	  the update that was successfully processed was received.  Because the server will always receive the
	  update after the client sent it, this avoids the possibility of misunderstandings.</t>

	  <t>DNS-SD Registration Protocol servers SHOULD reject updates that do not include a DNS update lease
	  time.   Dual-use servers may accept updates that don't include leases, but SHOULD differentiate between
	  DNS-SD registration protocol updates and other updates, and SHOULD reject updates that are known to
	  be DNS-SD registration protocol updates if they do not include leases.</t>
	</section>
	<section title="Sleep Proxy">
	  <t>Another use of Service Registration Protocol is for devices
	  that sleep to reduce power consumption.</t>

	  <t>In this case, in addition to the
	  <xref target="I-D.sekar-dns-ul">DNS Update Lease option</xref>
	  described above, the device includes an
	  <xref target="I-D.cheshire-edns0-owner-option">EDNS(0) OWNER Option</xref>.</t>

	  <t>The DNS Update Lease option constitutes a promise by the device
	  that it will wake up before this time elapses, to renew its records
	  and thereby demonstrate that it is still attached to the network.
	  If it fails to renew the records by this time, that indicates that it is
	  no longer attached to the network, and its records should be deleted.</t>

	  <t>The EDNS(0) OWNER Option indicates that the device will be asleep,
	  and will not be receptive to normal network traffic.
	  When a DNS server receives a DNS Update with an EDNS(0) OWNER Option,
	  that signifies that the Registration Service should set up a proxy for any
	  IPv4 or IPv6 address records in the DNS Update message.
	  This proxy should send ARP or ND messages claiming
	  ownership of the IPv4 and/or IPv6 addresses in the records in question.
	  In addition, proxy should answer future ARP or ND requests
	  for those IPv4 and/or IPv6 addresses, claiming ownership of them.
	  When the DNS server receives a TCP SYN or UDP packet addressed to
	  one of the IPv4 or IPv6 addresses for which it proxying, it should
	  then wake up the sleeping device using the information in the
	  EDNS(0) OWNER Option. At present version 0 of the OWNER Option
	  specifies the “Wake-on-LAN Magic Packet” that needs to be sent;
	  future versions could be extended to specify other wakeup mechanisms.</t>

	  <t>Note that although the authoritative DNS server that implements the DNSSD
	  Service Registration Protocol function need not be on the same link as the
	  sleeping host, the Sleep Proxy must be on the same link.</t>
	</section>
      </section>
    </section>


    <section title="Security Considerations">
      <t>DNS-SD Service Registration Protocol updates have no authorization semantics other than
      first-come, first-served.   This means that if an attacker from outside of the administrative
      domain of the server knows the server's IP address, it can in principle send updates to the server
      that will be processed successfully.   Servers should therefore be configured to reject updates
      from source addresses outside of the administrative domain of the server.</t>

      <t>Note that these rules only apply to the validation of DNS-SD registration
      protocol updates.   A server that accepts updates from DNS-SD registration protocol
      clients may also accept other DNS updates, and those DNS updates may be validated
      using different rules.   However, in the case of a DNS service that accepts automatic
      updates, the intersection of the DNS-SD service registration update rules and
      whatever other update rules are present must be considered very carefully.</t>

      <t>For example, a normal, authenticated RFC2136 update to any RR that was added using the
      Registration protocol, but that is authenticated using a different key, could be used to
      override a promise made by the registration protocol, by replacing all or part of the
      service registration information with information provided by a different client.  An
      implementation that allows both kinds of updates should not allow updates to records added
      by Registrations using different authentication and authorization credentials.</t>
    </section>
    <section title="Privacy Considerations">
    </section>
    <section title="Acknowledgments">
      <t>Thanks to Toke Høiland-Jørgensen for a thorough technical review, to Tamara Kemper for
      doing a nice developmental edit, and [...] more reviewers to come, hopefully.</t>
    </section>
  </middle>

  <back>
    <!-- <displayreference target="I-D.ietf-dnssd-hybrid" to="I-D.ietf-dnssd-hybrid"/> appears to not work in xml2rfc 2.6.2 -->
    <references title="Normative References">
      <?rfc include="reference.RFC.6763" anchor="RFC6763" ?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1034" ?>
      <?rfc include="reference.RFC.1035" ?>
      <?rfc include="reference.RFC.2131" ?>
      <?rfc include="reference.RFC.2136" ?>
      <?rfc include="reference.RFC.2931" ?>
      <?rfc include="reference.RFC.3007" ?>
      <?rfc include="reference.RFC.3152" ?>
      <?rfc include="reference.RFC.6760" ?>
      <?rfc include="reference.RFC.6762" ?>
      <?rfc include="reference.I-D.ietf-dnssd-hybrid"?>
      <?rfc include="reference.I-D.sekar-dns-ul" ?>
      <?rfc include="reference.I-D.cheshire-dnssd-roadmap" ?>
      <?rfc include="reference.I-D.cheshire-edns0-owner-option" ?>

      <reference anchor="ZC">
        <front>
          <title>Zero Configuration Networking: The Definitive Guide</title>
          <author initials="S." surname="Cheshire" fullname="Stuart Cheshire"/>
          <author initials="D.H." surname="Steinberg" fullname="Daniel H. Steinberg"/>
          <date year="2005" month="December"/>
        </front>
        <seriesInfo name="O'Reilly Media, Inc." value=""/>
        <seriesInfo name="ISBN" value="0-596-10100-7"/>
      </reference>

    </references>
  </back>
</rfc>
